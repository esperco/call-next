// Represents a declarative function call
export interface Cmd<F extends Function> {
  context?: any;
  fn: F;
  args: any[];
}

// Function that returns a promise
export type PromiseFn<T> = (...args: any[]) => Promise<T>;

/*
  NB: Type with `F & PromiseFn<any>` rather than `F extends PromiseFn<any>`
  to help TypeScript properly infer type of F.
*/
export interface CallFn {
  <F>(fn: F & PromiseFn<any>): F;
  <F>(context: any, fn: F & PromiseFn<any>): F;
  <C extends {[P in N]: PromiseFn<any>}, N extends string>(
    context: C, name: N
  ): C[N];
}

// Stubbed handler for CallFn
export type StubFn<T> = (cmd: Cmd<PromiseFn<T>>) => Promise<T>;

// Stubbing hook
let stub: StubFn<any>|undefined;
export const setStub = <T>(newStub?: StubFn<T>) => {
  stub = newStub;
};

/*
  Call function wraps another function. Default behavior is to simply wrap
  or bind function to a given context. If stubbing is active, return a
  promise generated by our stubbed function instead.

  Usage:

    call(myFn);
    call(context, myFn);
    call(context, "myFnName"); // If function is a property of context
*/
export const call: CallFn = (
  a1: PromiseFn<any>|any,
  a2?: PromiseFn<any>|string
) => {
  let context: any = undefined;
  let fn: PromiseFn<any>;
  if (a2) {
    context = a1;
    if (typeof a2 === "string") {
      fn = a1[a2];
    } else {
      fn = a2;
    }
  } else {
    fn = a1;
  }
  if (typeof fn !== "function") {
    throw new Error("No function provided.");
  }
  return (...args: any[]) => {
    return stub ? stub({ context, fn, args }) : fn.bind(context)(...args);
  };
};
