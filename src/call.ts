import { track, PromiseFn } from "./stub";

/*
  NB: Type with `F & PromiseFn<any>` rather than `F extends PromiseFn<any>`
  to help TypeScript properly infer type of F.
*/
export interface CallFn {
  <F>(fn: F & PromiseFn<any>): F;
  <F>(context: any, fn: F & PromiseFn<any>): F;
  <C extends {[P in N]: PromiseFn<any>}, N extends string>(
    context: C, name: N
  ): C[N];
}

/*
  Call function wraps another function. Default behavior is to simply wrap
  or bind function to a given context. If stubbing is active, return a
  promise generated by our stubbed function instead.

  Usage:

    call(myFn);
    call(context, myFn);
    call(context, "myFnName"); // If function is a property of context
*/
export const call: CallFn = (
  a1: PromiseFn<any>|any,
  a2?: PromiseFn<any>|string
) => {
  let context: any = undefined;
  let fn: PromiseFn<any>;
  if (a2) {
    context = a1;
    if (typeof a2 === "string") {
      fn = a1[a2];
    } else {
      fn = a2;
    }
  } else {
    fn = a1;
  }
  if (typeof fn !== "function") {
    throw new Error("No function provided.");
  }
  return (...args: any[]) => {
    return track({ context, fn, args }) || fn.bind(context)(...args);
  };
};
